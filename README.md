# Redis相关的项目

## 缓存穿透

### 描述

客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库

### 解决

- 缓存空对象
  - 优点：实现简单，维护方便
  - 缺点：可能造成数据短期不一致(新增数据时写缓存则不会存在问题)
- 布隆过滤
  - 实现方式：
    - 添加数据时：将Key Hash多次，在Bitmap中将hash值设为1
    - 获取数据时：以想同的方式将Key Hash多次，得到的Hash值在Bitmap中是否都为1
  - 优点：内存占有少
  - 缺点：存在误判

## 缓存雪崩

### 描述

在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库

### 解决

- 给不同的Key的TTL添加随机值

## 缓存击穿

### 描述

一个被高并发访问并且缓存重建业务较复杂的key突然失效了

### 解决

- 互斥锁
  - 描述：使用分布式锁来解决，获取锁的线程去构建该缓存，其他线程则等待
- 逻辑过期
  - 描述：给redis设置逻辑过期时间(添加一个过期字段)，达到逻辑过期则获取分布式锁，获取锁的线程开启新线程去构建缓存，并返回旧值，其他线程直接返回旧值

## 秒杀

### 业务描述

1、有管理端和客户端
2、商户可以在管理端中添加秒杀券(可设置一些规则：秒杀券的数量、一个用户最多可以购买几张等)
3、用户可以在客户端购买秒杀券

### 解决方案

商户上架秒杀券后，在redis中保存该秒杀券id及数量
用户购买时

- 通过lua脚本与redis交互
  - a.秒杀券数量是否大于0
  - b.用户是否购买数量超过了最大数量,
- 验证通过则在redis中
  - a.将秒杀券数量减1
  - b.该用户购买数量加1
- 生成唯一id作为订单id，将用户id、优惠券id、订单id发送给mq，由后台线程异步操作数据库，并将订单id返回给前端

## 分布式锁

- 使用 `setnx`
  - 缺点：获取锁的线程，在释放锁之前 挂掉，导致无法释放锁
- 使用 `setex`
  - 缺点：获取锁的线程，阻塞了一段时间，锁过期之后，又删除了不属于自己的锁
- `value` 给一个唯一值，删除锁时做判断
  - 缺点：判断与删除无法保证原子性，导致删除了不属于自己的锁
- 使用 `Redisson`
  - 优点：可重入、可重试、超时释放、主从一致性
  - 可重入：使用的是 `hash` 类型，`field` 为唯一值，`value` 为获取锁的次数，实现可重入
  - 可重试：获取锁失败后，会订阅redis(删除锁时，会发布)
  - 超时释放：获取锁后会会由另一个线程每隔10s监听，拥有锁的是不是当前线程，是的话会执行喂狗操作
    - 只有未设置锁锁自动释放时间才会触发看门狗动作，默认值为30s，看门狗监听的周期是该值/3
  - 主从一致性：Redisson 的联锁、红锁

